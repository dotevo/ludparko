{"mappings":"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","sources":["src/index.ts","src/overpass-layer.ts","node_modules/cash-dom/dist/cash.ts","src/overpass-fetcher.ts","src/download-queue.ts"],"sourcesContent":["import * as L from \"leaflet\";\nimport { OverpassLayer } from \"./overpass-layer\";\nimport { OverpassFetcher } from \"./overpass-fetcher\";\n\nconst map = L.map(\"map\").setView([43.659752, -79.378161], 10);\n\nL.tileLayer(\"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png\", {\n  attribution:\n    '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> &copy; <a href=\"https://carto.com/attributions\">CARTO</a>',\n  subdomains: \"abcd\",\n  maxZoom: 21,\n}).addTo(map);\n\nconst query = `way[leisure=playground](%BBOX%);\nmap_to_area;\n\nforeach->.d(\n   node(area.d)\n     (if: is_tag(\"amenity\") || is_tag(\"playground\") ) -> .a;\n   .a out skel;\n   .a convert node\n    ::=::, \n    ::id=id(),\n    playground_id=d.min(id());\n   out;\n  \n   way(area.d)[playground] -> .b;\n   .b out geom;\n   .b convert way\n    ::=::, \n    ::id=id(),\n    playground_id=d.min(id()),\n    size=length();\n  out;\n  (.a;.b;) -> .c;  \n  \n  .d out geom;\n  .d convert way\n    ::=::,\n    ::id=id(),\n    playground_in=c.set(t[\"playground\"]),\n    amenity_in=c.set(t[\"amenity\"]);\n  out; \n);`;\n\nmap.addLayer(new OverpassLayer(new OverpassFetcher(query, 0.04)));\n\nfunction updateHash() {\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  window.location.hash = `#${center.lat.toFixed(4)},${center.lng.toFixed(\n    4\n  )},${zoom}`;\n}\n\nfunction setMapFromHash() {\n  const hash = window.location.hash.substr(1);\n  if (hash) {\n    const [lat, lng, zoom] = hash.split(\",\");\n    map.setView([parseFloat(lat), parseFloat(lng)], parseInt(zoom));\n  }\n}\n\nmap.on(\"moveend\", updateHash);\nmap.on(\"zoomend\", updateHash);\n\nsetMapFromHash();\n","import * as L from \"leaflet\";\nimport { OverpassFetcher } from \"./overpass-fetcher\";\nimport $ from \"../node_modules/cash-dom/dist/cash\";\n\nexport class OverpassLayer extends L.FeatureGroup {\n  private icons: L.Marker[] = [];\n  private ids = new Map<string, object>();\n\n  constructor(readonly fetcher: OverpassFetcher) {\n    super();\n\n    fetcher.setOverpassLayer(this);\n  }\n\n  private onScreenChanged(map: L.Map) {\n    if (map.getZoom() > 15) {\n      this.fetcher.fetchData(map.getBounds());\n    }\n  }\n\n  public addData(data: any) {\n    const ways = {};\n    const nodes = {};\n\n    data.elements.forEach((element: any) => {\n      if (element.type === \"way\") {\n        ways[element.id] = { ...ways[element.id], ...element };\n      }\n      if (element.type === \"node\") {\n        nodes[element.id] = { ...nodes[element.id], ...element };\n      }\n    });\n\n    Object.keys(ways).forEach((key: any) => {\n      const element = ways[key];\n      // Skip if already added to the map\n      if (this.ids[\"w\" + element.id] !== undefined) {\n        return;\n      }\n      this.ids[\"w\" + element.id] = element;\n\n      if (element.geometry) {\n        const coordinates: L.LatLngLiteral[] = element.geometry.map(\n          (geometry: any) => ({\n            lat: geometry.lat,\n            lng: geometry.lon,\n          })\n        );\n\n        if (element.tags.leisure === \"playground\") {\n          const polygon = L.polygon(coordinates, {\n            color: \"blue\",\n            fillOpacity: 0.4,\n          });\n\n          this.addLayer(polygon);\n        } else {\n          const polygon = L.polygon(coordinates, {\n            color: \"yellow\",\n            fillOpacity: 0.4,\n          });\n\n          this.addLayer(polygon);\n        }\n      }\n    });\n\n    Object.keys(nodes).forEach((key: any) => {\n      const element = nodes[key];\n      // Skip if already added to the map\n      if (this.ids[\"n\" + element.id] !== undefined) {\n        return;\n      }\n      this.ids[\"n\" + element.id] = element;\n\n      if (element.lat && element.lon && element.tags) {\n        const marker = L.marker([element.lat, element.lon], {\n          icon: new L.DivIcon({\n            html:\n              \"<div class='playgroundIcon \" +\n              this.getClassName(element.tags) +\n              \"'></div>\",\n          }),\n        });\n        if (element) {\n          marker.bindPopup(JSON.stringify(element.tags));\n        }\n        this.icons.push(marker);\n\n        this.addLayer(marker);\n      }\n    });\n  }\n\n  private getClassName(tags: object) {\n    if (tags[\"amenity\"] !== undefined) {\n      return \"icon-amenity-\" + tags[\"amenity\"] + \" icon-amenity-default\";\n    }\n    if (tags[\"playground\"] !== undefined) {\n      return (\n        \"icon-playground-\" + tags[\"playground\"] + \" icon-playground-default\"\n      );\n    }\n    return \"\";\n  }\n\n  public onAdd(map: L.Map) {\n    // FIXME: clean in onRemove\n    console.log(\"added\");\n    const self = this;\n    map.on(\"zoomend\", () => {\n      self.onScreenChanged(map);\n      const zoom = map.getZoom();\n      const size = Math.pow(2, Math.max(zoom - 14, 1));\n      this.icons.forEach((marker) => {\n        const icon = marker.getIcon();\n        icon.options.iconAnchor = [size / 2, size / 2];\n        icon.options.iconSize = [size, size];\n        marker.setIcon(marker.getIcon());\n      });\n\n      $(\".playgroundIcon\").css(\"width\", size + \"px\");\n      $(\".playgroundIcon\").css(\"height\", size + \"px\");\n    });\n    map.on(\"dragend\", () => {\n      self.onScreenChanged(map);\n    });\n    return this;\n  }\n\n  public onRemove(map: L.Map) {\n    console.log(\"on remove\");\n    return this;\n  }\n}\n","\ninterface Event {\n  namespace: string,\n  data: any,\n  relatedTarget?: Node | null,\n  ___ifocus?: boolean, // Ignore focus\n  ___iblur?: boolean, // Ignore blur\n  ___ot?: string, // Original type\n  ___td?: boolean // Trigger data\n}\n\ninterface Cash {\n  [Symbol.iterator](): IterableIterator<EleLoose>,\n  [index: number]: EleLoose | undefined,\n  length: number,\n  splice ( start: number, deleteCount?: number ): EleLoose[],\n  splice ( start: number, deleteCount: number, ...items: Ele[] ): EleLoose[]\n}\n\ninterface CashStatic {\n  fn: Cash\n}\n\ntype falsy = undefined | null | false | 0 | '';\n\ntype Ele = Window | Document | HTMLElement | Element | Node;\ntype EleLoose = HTMLElement & Element & Node; //UGLY: Trick to remove some kind-of useless type errors //URL: https://github.com/fabiospampinato/cash/issues/278\ntype Selector = falsy | string | Function | HTMLCollection | NodeList | Ele | Ele[] | ArrayLike<Ele> | Cash;\ntype Comparator = string | Ele | Cash | (( this: EleLoose, index: number, ele: EleLoose ) => boolean);\ntype Context = Document | HTMLElement | Element | string;\n\ntype PlainObject<T> = Record<string, T>; //FIXME: Arrays can be assigned to this type, for whatever reason\n\ntype EventCallback = {\n  ( event: any, data?: any ): any,\n  guid?: number\n};\n\n\nconst doc = document;\nconst win = window;\nconst docEle = doc.documentElement;\nconst createElement = doc.createElement.bind ( doc );\nconst div = createElement ( 'div' );\nconst table = createElement ( 'table' );\nconst tbody = createElement ( 'tbody' );\nconst tr = createElement ( 'tr' );\nconst {isArray, prototype: ArrayPrototype} = Array;\nconst {concat, filter, indexOf, map, push, slice, some, splice} = ArrayPrototype;\n\nconst idRe = /^#(?:[\\w-]|\\\\.|[^\\x00-\\xa0])*$/;\nconst classRe = /^\\.(?:[\\w-]|\\\\.|[^\\x00-\\xa0])*$/;\nconst htmlRe = /<.+>/;\nconst tagRe = /^\\w+$/;\n\n\n// @require ./variables.ts\n\nfunction find ( selector: string, context: Ele ): ArrayLike<Element> {\n\n  const isFragment = isDocumentFragment ( context );\n\n  return !selector || ( !isFragment && !isDocument ( context ) && !isElement ( context ) )\n           ? []\n           : !isFragment && classRe.test ( selector )\n             ? context.getElementsByClassName ( selector.slice ( 1 ).replace ( /\\\\/g, '' ) )\n             : !isFragment && tagRe.test ( selector )\n               ? context.getElementsByTagName ( selector )\n               : context.querySelectorAll ( selector );\n\n}\n\n\n// @require ./find.ts\n// @require ./variables.ts\n\nclass Cash {\n\n  constructor ( selector?: Selector, context?: Context | Cash ) {\n\n    if ( !selector ) return;\n\n    if ( isCash ( selector ) ) return selector;\n\n    let eles: any = selector;\n\n    if ( isString ( selector ) ) {\n\n      const ctx = context || doc;\n\n      eles = idRe.test ( selector ) && isDocument ( ctx )\n                ? ctx.getElementById ( selector.slice ( 1 ).replace ( /\\\\/g, '' ) )\n                : htmlRe.test ( selector )\n                  ? parseHTML ( selector )\n                  : isCash ( ctx )\n                    ? ctx.find ( selector )\n                      : isString ( ctx )\n                        ? cash ( ctx ).find ( selector )\n                        : find ( selector, ctx );\n\n      if ( !eles ) return;\n\n    } else if ( isFunction ( selector ) ) {\n\n      return this.ready ( selector ); //FIXME: `fn.ready` is not included in `core`, but it's actually a core functionality\n\n    }\n\n    if ( eles.nodeType || eles === win ) eles = [eles];\n\n    this.length = eles.length;\n\n    for ( let i = 0, l = this.length; i < l; i++ ) {\n\n      this[i] = eles[i];\n\n    }\n\n  }\n\n  init ( selector?: Selector, context?: Context | Cash ) {\n\n    return new Cash ( selector, context );\n\n  }\n\n}\n\nconst fn = Cash.prototype;\nconst cash = fn.init as ( typeof Cash.prototype.init & CashStatic );\n\ncash.fn = cash.prototype = fn; // Ensuring that `cash () instanceof cash`\n\nfn.length = 0;\nfn.splice = splice; // Ensuring a cash collection gets printed as array-like in Chrome's devtools\n\nif ( typeof Symbol === 'function' ) { // Ensuring a cash collection is iterable\n  fn[Symbol['iterator']] = ArrayPrototype[Symbol['iterator']];\n}\n\n\n// @require ./cash.ts\n// @require ./variables.ts\n\ninterface CashStatic {\n  isWindow ( x: unknown ): x is Window;\n  isFunction ( x: unknown ): x is Function;\n  isArray ( x: unknown ): x is Array<any>;\n  isNumeric ( x: unknown ): boolean;\n  isPlainObject ( x: unknown ): x is PlainObject<any>;\n}\n\nfunction isCash ( value: unknown ): value is Cash {\n\n  return value instanceof Cash;\n\n}\n\nfunction isWindow ( value: unknown ): value is Window {\n\n  return !!value && value === value.window;\n\n}\n\nfunction isDocument ( value: unknown ): value is Document {\n\n  return !!value && value.nodeType === 9;\n\n}\n\nfunction isDocumentFragment ( value: unknown ): value is DocumentFragment {\n\n  return !!value && value.nodeType === 11;\n\n}\n\nfunction isElement ( value: unknown ): value is HTMLElement {\n\n  return !!value && value.nodeType === 1;\n\n}\n\nfunction isText ( value: unknown ): value is Text {\n\n  return !!value && value.nodeType === 3;\n\n}\n\nfunction isBoolean ( value: unknown ): value is boolean {\n\n  return typeof value === 'boolean';\n\n}\n\nfunction isFunction ( value: unknown ): value is Function {\n\n  return typeof value === 'function';\n\n}\n\nfunction isString ( value: unknown ): value is string {\n\n  return typeof value === 'string';\n\n}\n\nfunction isUndefined ( value: unknown ): value is undefined {\n\n  return value === undefined;\n\n}\n\nfunction isNull ( value: unknown ): value is null {\n\n  return value === null;\n\n}\n\nfunction isNumeric ( value: unknown ): boolean {\n\n  return !isNaN ( parseFloat ( value ) ) && isFinite ( value );\n\n}\n\nfunction isPlainObject ( value: unknown ): value is PlainObject<any> {\n\n  if ( typeof value !== 'object' || value === null ) return false;\n\n  const proto = Object.getPrototypeOf ( value );\n\n  return proto === null || proto === Object.prototype;\n\n}\n\ncash.isWindow = isWindow;\ncash.isFunction = isFunction;\ncash.isArray = isArray;\ncash.isNumeric = isNumeric;\ncash.isPlainObject = isPlainObject;\n\n\n// @require ./cash.ts\n// @require ./type_checking.ts\n\ntype EachArrayCallback<T> = ( this: T, index: number, ele: T ) => any;\ntype EachObjectCallback<T> = ( this: T, key: string, value: T ) => any;\n\ninterface CashStatic {\n  each<T> ( arr: ArrayLike<T>, callback: EachArrayCallback<T> ): void;\n  each<T> ( obj: PlainObject<T>, callback: EachObjectCallback<T> ): void;\n}\n\nfunction each<T, U extends ArrayLike<T> = ArrayLike<T>> ( arr: U, callback: EachArrayCallback<T>, _reverse?: boolean ): U;\nfunction each<T, U extends PlainObject<T> = PlainObject<T>> ( obj: U, callback: EachObjectCallback<T> ): U;\nfunction each<T, U extends ArrayLike<T> | PlainObject<T> = ArrayLike<T>> ( arr: U, callback: EachArrayCallback<T> | EachObjectCallback<T>, _reverse?: boolean ): U {\n\n  if ( _reverse ) {\n\n    let i = arr.length;\n\n    while ( i-- ) {\n\n      if ( callback.call ( arr[i], i, arr[i] ) === false ) return arr;\n\n    }\n\n  } else if ( isPlainObject ( arr ) ) {\n\n    const keys = Object.keys ( arr );\n\n    for ( let i = 0, l = keys.length; i < l; i++ ) {\n\n      const key = keys[i];\n\n      if ( callback.call ( arr[key], key, arr[key] ) === false ) return arr;\n\n    }\n\n  } else {\n\n    for ( let i = 0, l = arr.length; i < l; i++ ) {\n\n      if ( callback.call ( arr[i], i, arr[i] ) === false ) return arr;\n\n    }\n\n  }\n\n  return arr;\n\n}\n\ncash.each = each;\n\n\n// @require core/cash.ts\n// @require core/each.ts\n\ninterface Cash {\n  each ( callback: EachArrayCallback<EleLoose> ): this;\n}\n\nfn.each = function ( this: Cash, callback: EachArrayCallback<EleLoose> ) {\n\n  return each ( this, callback );\n\n};\n\n\n// @require core/cash.ts\n// @require collection/each.ts\n\ninterface Cash {\n  empty (): this;\n}\n\nfn.empty = function ( this: Cash ) {\n\n  return this.each ( ( i, ele ) => {\n\n    while ( ele.firstChild ) {\n\n      ele.removeChild ( ele.firstChild );\n\n    }\n\n  });\n\n};\n\n\n// @require ./cash.ts\n// @require ./type_checking.ts\n\ninterface CashStatic {\n  extend (): any;\n  extend ( deep: true, target: any, ...sources: any[] ): any;\n  extend ( target: any ): typeof cash;\n  extend ( target: any, ...sources: any[] ): any;\n}\n\ninterface Cash {\n  extend ( plugins: Record<any, any> ): this;\n}\n\nfunction extend ( ...sources: any[] ) {\n\n  const deep = isBoolean ( sources[0] ) ? sources.shift () : false;\n  const target = sources.shift ();\n  const length = sources.length;\n\n  if ( !target ) return {};\n\n  if ( !length ) return extend ( deep, cash, target );\n\n  for ( let i = 0; i < length; i++ ) {\n\n    const source = sources[i];\n\n    for ( const key in source ) {\n\n      if ( deep && ( isArray ( source[key] ) || isPlainObject ( source[key] ) ) ) {\n\n        if ( !target[key] || target[key].constructor !== source[key].constructor ) target[key] = new source[key].constructor ();\n\n        extend ( deep, target[key], source[key] );\n\n      } else {\n\n        target[key] = source[key];\n\n      }\n\n    }\n\n  }\n\n  return target;\n\n}\n\ncash.extend = extend;\n\nfn.extend = function ( plugins: Record<string, any> ) {\n\n  return extend ( fn, plugins );\n\n};\n\n\n// @require ./type_checking.ts\n\nconst splitValuesRe = /\\S+/g;\n\nfunction getSplitValues ( str: string ) {\n\n  return isString ( str ) ? str.match ( splitValuesRe ) || [] : [];\n\n}\n\n\n// @require core/cash.ts\n// @require core/each.ts\n// @require core/get_split_values.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n\ninterface Cash {\n  toggleClass ( classes: string, force?: boolean ): this;\n}\n\nfn.toggleClass = function ( this: Cash, cls: string, force?: boolean ) {\n\n  const classes = getSplitValues ( cls );\n  const isForce = !isUndefined ( force );\n\n  return this.each ( ( i, ele ) => {\n\n    if ( !isElement ( ele ) ) return;\n\n    each ( classes, ( i, c ) => {\n\n      if ( isForce ) {\n\n        force ? ele.classList.add ( c ) : ele.classList.remove ( c );\n\n      } else {\n\n        ele.classList.toggle ( c );\n\n      }\n\n    });\n\n  });\n\n};\n\n\n// @require core/cash.ts\n// @require ./toggle_class.ts\n\ninterface Cash {\n  addClass ( classes: string ): this;\n}\n\nfn.addClass = function ( this: Cash, cls: string ) {\n\n  return this.toggleClass ( cls, true );\n\n};\n\n\n// @require core/cash.ts\n// @require core/get_split_values.ts\n// @require collection/each.ts\n\ninterface Cash {\n  removeAttr ( attrs: string ): this;\n}\n\nfn.removeAttr = function ( this: Cash, attr: string ) {\n\n  const attrs = getSplitValues ( attr );\n\n  return this.each ( ( i, ele ) => {\n\n    if ( !isElement ( ele ) ) return;\n\n    each ( attrs, ( i, a ) => {\n\n      ele.removeAttribute ( a );\n\n    });\n\n  });\n\n};\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require ./remove_attr.ts\n\ninterface Cash {\n  attr (): undefined;\n  attr ( attrs: string ): string | null;\n  attr ( attrs: string, value: string ): this;\n  attr ( attrs: Record<string, string> ): this;\n}\n\nfunction attr ( this: Cash ): undefined;\nfunction attr ( this: Cash, attr: string ): string | null;\nfunction attr ( this: Cash, attr: string, value: string ): Cash;\nfunction attr ( this: Cash, attr: Record<string, string> ): Cash;\nfunction attr ( this: Cash, attr?: string | Record<string, string>, value?: string ) {\n\n  if ( !attr ) return;\n\n  if ( isString ( attr ) ) {\n\n    if ( arguments.length < 2 ) {\n\n      if ( !this[0] || !isElement ( this[0] ) ) return;\n\n      const value = this[0].getAttribute ( attr );\n\n      return isNull ( value ) ? undefined : value;\n\n    }\n\n    if ( isUndefined ( value ) ) return this;\n\n    if ( isNull ( value ) ) return this.removeAttr ( attr );\n\n    return this.each ( ( i, ele ) => {\n\n      if ( !isElement ( ele ) ) return;\n\n      ele.setAttribute ( attr, value )\n\n    });\n\n  }\n\n  for ( const key in attr ) {\n\n    this.attr ( key, attr[key] );\n\n  }\n\n  return this;\n\n}\n\nfn.attr = attr;\n\n\n// @require core/cash.ts\n// @require ./attr.ts\n// @require ./toggle_class.ts\n\ninterface Cash {\n  removeClass ( classes?: string ): this;\n}\n\nfn.removeClass = function ( this: Cash, cls?: string ) {\n\n  if ( arguments.length ) return this.toggleClass ( cls, false );\n\n  return this.attr ( 'class', '' );\n\n};\n\n\n// @require core/cash.ts\n// @require core/get_split_values.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n\ninterface Cash {\n  hasClass ( cls: string ): boolean;\n}\n\nfn.hasClass = function ( this: Cash, cls: string ) {\n\n  return !!cls && some.call ( this, ( ele: EleLoose ) => isElement ( ele ) && ele.classList.contains ( cls ) );\n\n};\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require core/variables.ts\n\ninterface Cash {\n  get (): EleLoose[];\n  get ( index: number ): EleLoose | undefined;\n}\n\nfn.get = function ( this: Cash, index?: number ) {\n\n  if ( isUndefined ( index ) ) return slice.call ( this );\n\n  index = Number ( index );\n\n  return this[index < 0 ? index + this.length : index];\n\n};\n\n\n// @require core/cash.ts\n// @require ./get.ts\n\ninterface Cash {\n  eq ( index: number ): Cash;\n}\n\nfn.eq = function ( this: Cash, index: number ) {\n\n  return cash ( this.get ( index ) );\n\n};\n\n\n// @require core/cash.ts\n// @require ./eq.ts\n\ninterface Cash {\n  first (): Cash;\n}\n\nfn.first = function ( this: Cash ) {\n\n  return this.eq ( 0 );\n\n};\n\n\n// @require core/cash.ts\n// @require ./eq.ts\n\ninterface Cash {\n  last (): Cash;\n}\n\nfn.last = function ( this: Cash ) {\n\n  return this.eq ( -1 );\n\n};\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require collection/get.ts\n\ninterface Cash {\n  text (): string;\n  text ( text: string ): this;\n}\n\nfunction text ( this: Cash ): string;\nfunction text ( this: Cash, text: string ): Cash;\nfunction text ( this: Cash, text?: string ) {\n\n  if ( isUndefined ( text ) ) {\n\n    return this.get ().map ( ele => isElement ( ele ) || isText ( ele ) ? ele.textContent : '' ).join ( '' );\n\n  }\n\n  return this.each ( ( i, ele ) => {\n\n    if ( !isElement ( ele ) ) return;\n\n    ele.textContent = text;\n\n  });\n\n}\n\nfn.text = text;\n\n\n// @require core/type_checking.ts\n// @require core/variables.ts\n\nfunction computeStyle ( ele: EleLoose, prop: string, isVariable?: boolean ): string | undefined {\n\n  if ( !isElement ( ele ) ) return;\n\n  const style = win.getComputedStyle ( ele, null );\n\n  return isVariable ? style.getPropertyValue ( prop ) || undefined : style[prop] || ele.style[prop];\n\n}\n\n\n// @require ./compute_style.ts\n\nfunction computeStyleInt ( ele: EleLoose, prop: string ): number {\n\n  return parseInt ( computeStyle ( ele, prop ), 10 ) || 0;\n\n}\n\n\n// @require css/helpers/compute_style_int.ts\n\nfunction getExtraSpace ( ele: EleLoose, xAxis?: boolean ): number {\n\n  return computeStyleInt ( ele, `border${ xAxis ? 'Left' : 'Top' }Width` ) + computeStyleInt ( ele, `padding${ xAxis ? 'Left' : 'Top' }` ) + computeStyleInt ( ele, `padding${ xAxis ? 'Right' : 'Bottom' }` ) + computeStyleInt ( ele, `border${ xAxis ? 'Right' : 'Bottom' }Width` );\n\n}\n\n\n// @require css/helpers/compute_style.ts\n\nconst defaultDisplay: { [tagName: string]: string } = {};\n\nfunction getDefaultDisplay ( tagName: string ): string {\n\n  if ( defaultDisplay[tagName] ) return defaultDisplay[tagName];\n\n  const ele = createElement ( tagName );\n\n  doc.body.insertBefore ( ele, null );\n\n  const display = computeStyle ( ele, 'display' );\n\n  doc.body.removeChild ( ele );\n\n  return defaultDisplay[tagName] = display !== 'none' ? display : 'block';\n\n}\n\n\n// @require css/helpers/compute_style.ts\n\nfunction isHidden ( ele: EleLoose ): boolean {\n\n  return computeStyle ( ele, 'display' ) === 'none';\n\n}\n\n\n// @require ./cash.ts\n\nfunction matches ( ele: any, selector: string ): boolean {\n\n  const matches = ele && ( ele['matches'] || ele['webkitMatchesSelector'] || ele['msMatchesSelector'] );\n\n  return !!matches && !!selector && matches.call ( ele, selector );\n\n}\n\n\n// @require ./matches.ts\n// @require ./type_checking.ts\n\nfunction getCompareFunction ( comparator?: Comparator ): (( i: number, ele: EleLoose ) => boolean) {\n\n  return isString ( comparator )\n           ? ( i: number, ele: EleLoose ) => matches ( ele, comparator )\n           : isFunction ( comparator )\n             ? comparator\n             : isCash ( comparator )\n               ? ( i: number, ele: EleLoose ) => comparator.is ( ele )\n               : !comparator\n                 ? () => false\n                 : ( i: number, ele: EleLoose ) => ele === comparator;\n\n}\n\n\n// @require core/cash.ts\n// @require core/get_compare_function.ts\n// @require core/type_checking.ts\n// @require core/variables.ts\n// @require collection/get.ts\n\ninterface Cash {\n  filter ( comparator?: Comparator ): Cash;\n}\n\nfn.filter = function ( this: Cash, comparator?: Comparator ) {\n\n  const compare = getCompareFunction ( comparator );\n\n  return cash ( filter.call ( this, ( ele: EleLoose, i: number ) => compare.call ( ele, i, ele ) ) );\n\n};\n\n\n// @require collection/filter.ts\n\nfunction filtered ( collection: Cash, comparator?: Comparator ): Cash {\n\n  return !comparator ? collection : collection.filter ( comparator );\n\n}\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require collection/each.ts\n\ninterface Cash {\n  detach ( comparator?: Comparator ): this;\n}\n\nfn.detach = function ( this: Cash, comparator?: Comparator ) {\n\n  filtered ( this, comparator ).each ( ( i, ele ) => {\n\n    if ( ele.parentNode ) {\n\n      ele.parentNode.removeChild ( ele );\n\n    }\n\n  });\n\n  return this;\n\n};\n\n\n// @require ./cash.ts\n// @require ./variables.ts\n// @require ./type_checking.ts\n// @require collection/get.ts\n// @require manipulation/detach.ts\n\ninterface CashStatic {\n  parseHTML ( html: string ): EleLoose[];\n}\n\nconst fragmentRe = /^\\s*<(\\w+)[^>]*>/;\nconst singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\nconst containers = {\n  '*': div,\n  tr: tbody,\n  td: tr,\n  th: tr,\n  thead: table,\n  tbody: table,\n  tfoot: table\n};\n\n//TODO: Create elements inside a document fragment, in order to prevent inline event handlers from firing\n//TODO: Ensure the created elements have the fragment as their parent instead of null, this also ensures we can deal with detatched nodes more reliably\n\nfunction parseHTML ( html: string ): EleLoose[] {\n\n  if ( !isString ( html ) ) return [];\n\n  if ( singleTagRe.test ( html ) ) return [createElement ( RegExp.$1 )];\n\n  const fragment = fragmentRe.test ( html ) && RegExp.$1;\n  const container = containers[fragment] || containers['*'];\n\n  container.innerHTML = html;\n\n  return cash ( container.childNodes ).detach ().get ();\n\n}\n\ncash.parseHTML = parseHTML;\n\n\n// @require core/cash.ts\n// @require core/find.ts\n// @require core/type_checking.ts\n// @require collection/filter.ts\n\ninterface Cash {\n  has ( selector: string | Node ): Cash;\n}\n\nfn.has = function ( this: Cash, selector: string | Node ) {\n\n  const comparator = isString ( selector )\n                       ? ( i: number, ele: EleLoose ) => find ( selector, ele ).length\n                       : ( i: number, ele: EleLoose ) => ele.contains ( selector );\n\n  return this.filter ( comparator );\n\n};\n\n\n// @require core/cash.ts\n// @require core/get_compare_function.ts\n// @require core/type_checking.ts\n// @require collection/filter.ts\n\ninterface Cash {\n  not ( comparator?: Comparator ): Cash;\n}\n\nfn.not = function ( this: Cash, comparator?: Comparator ) {\n\n  const compare = getCompareFunction ( comparator );\n\n  return this.filter ( ( i: number, ele: EleLoose ) => ( !isString ( comparator ) || isElement ( ele ) ) && !compare.call ( ele, i, ele ) );\n\n};\n\n\n// @require ./get_compare_function.ts\n// @require ./type_checking.ts\n// @require ./variables.ts\n\ntype PluckCallback<T> = ( ele: T ) => ArrayLike<Ele>;\n\nfunction pluck<T, U extends ArrayLike<T> = ArrayLike<T>> ( arr: U, prop: string | PluckCallback<U[0]>, deep?: boolean, until?: Comparator ): Array<Ele> {\n\n  const plucked: Array<Ele> = [];\n  const isCallback = isFunction ( prop );\n  const compare = until && getCompareFunction ( until );\n\n  for ( let i = 0, l = arr.length; i < l; i++ ) {\n\n    if ( isCallback ) {\n\n      const val = prop ( arr[i] );\n\n      if ( val.length ) push.apply ( plucked, val );\n\n    } else {\n\n      let val = arr[i][prop];\n\n      while ( val != null ) {\n\n        if ( until && compare ( -1, val ) ) break;\n\n        plucked.push ( val );\n\n        val = deep ? val[prop] : null;\n\n      }\n\n    }\n\n  }\n\n  return plucked;\n\n}\n\n\n// @require core/pluck.ts\n// @require core/variables.ts\n\nfunction getValue ( ele: EleLoose ): string | string[] {\n\n  if ( ele.multiple && ele.options ) return pluck ( filter.call ( ele.options, option => option.selected && !option.disabled && !option.parentNode.disabled ), 'value' );\n\n  return ele.value || '';\n\n}\n\n\n// @require core/cash.ts\n// @require core/each.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require ./helpers/get_value.ts\n\ninterface Cash {\n  val (): string | string[];\n  val ( value: string | string[] ): this;\n}\n\nfunction val ( this: Cash ): string | string[];\nfunction val ( this: Cash, value: string | string[] ): Cash;\nfunction val ( this: Cash, value?: string | string[] ) {\n\n  if ( !arguments.length ) return this[0] && getValue ( this[0] );\n\n  return this.each ( ( i, ele ) => {\n\n    const isSelect = ele.multiple && ele.options;\n\n    if ( isSelect || checkableRe.test ( ele.type ) ) {\n\n      const eleValue = isArray ( value ) ? map.call ( value, String ) : ( isNull ( value ) ? [] : [String ( value )] );\n\n      if ( isSelect ) {\n\n        each ( ele.options, ( i, option ) => {\n\n          option.selected = eleValue.indexOf ( option.value ) >= 0;\n\n        }, true );\n\n      } else {\n\n        ele.checked = eleValue.indexOf ( ele.value ) >= 0;\n\n      }\n\n    } else {\n\n      ele.value = isUndefined ( value ) || isNull ( value ) ? '' : value;\n\n    }\n\n  });\n\n}\n\nfn.val = val;\n\n\n// @require core/cash.ts\n// @require core/get_compare_function.ts\n// @require core/variables.ts\n// @require collection/each.ts\n\ninterface Cash {\n  is ( comparator?: Comparator ): boolean;\n}\n\nfn.is = function ( this: Cash, comparator?: Comparator ) {\n\n  const compare = getCompareFunction ( comparator );\n\n  return some.call ( this, ( ele: EleLoose, i: number ) => compare.call ( ele, i, ele ) );\n\n};\n\n\n// @require ./cash.ts\n\ninterface CashStatic {\n  guid: number;\n}\n\ncash.guid = 1;\n\n\n// @require ./cash.ts\n// @require ./variables.ts\n\ninterface CashStatic {\n  unique<T> ( arr: ArrayLike<T> ): ArrayLike<T>;\n}\n\nfunction unique<T> ( arr: ArrayLike<T> ): ArrayLike<T> {\n\n  return arr.length > 1 ? filter.call ( arr, ( item: T, index: number, self: ArrayLike<T> ) => indexOf.call ( self, item ) === index ) : arr;\n\n}\n\ncash.unique = unique;\n\n\n// @require core/cash.ts\n// @require core/unique.ts\n// @require ./get.ts\n\ninterface Cash {\n  add ( selector: Selector, context?: Context ): Cash;\n}\n\nfn.add = function ( this: Cash, selector: Selector, context?: Context ) {\n\n  return cash ( unique ( this.get ().concat ( cash ( selector, context ).get () ) ) );\n\n};\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require core/pluck.ts\n// @require core/unique.ts\n// @require core/variables.ts\n// @require collection/each.ts\n\ninterface Cash {\n  children ( comparator?: Comparator ): Cash;\n}\n\nfn.children = function ( this: Cash, comparator?: Comparator ) {\n\n  return filtered ( cash ( unique ( pluck ( this, ele => ele.children ) ) ), comparator );\n\n};\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require core/pluck.ts\n// @require core/unique.ts\n\ninterface Cash {\n  parent ( comparator?: Comparator ): Cash;\n}\n\nfn.parent = function ( this: Cash, comparator?: Comparator ) {\n\n  return filtered ( cash ( unique ( pluck ( this, 'parentNode' ) ) ), comparator );\n\n};\n\n\n// @require core/cash.ts\n// @require core/variables.ts\n// @require traversal/children.ts\n// @require traversal/parent.ts\n// @require ./get.ts\n\ninterface Cash {\n  index ( selector?: Selector ): number;\n}\n\nfn.index = function ( this: Cash, selector?: Selector ) {\n\n  const child = selector ? cash ( selector )[0] : this[0];\n  const collection = selector ? this : cash ( child ).parent ().children ();\n\n  return indexOf.call ( collection, child );\n\n};\n\n\n// @require core/cash.ts\n// @require collection/filter.ts\n// @require ./is.ts\n// @require ./parent.ts\n\ninterface Cash {\n  closest ( comparator?: Comparator ): Cash;\n}\n\nfn.closest = function ( this: Cash, comparator?: Comparator ) {\n\n  const filtered = this.filter ( comparator );\n\n  if ( filtered.length ) return filtered;\n\n  const $parent = this.parent ();\n\n  if ( !$parent.length ) return filtered;\n\n  return $parent.closest ( comparator );\n\n};\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require core/pluck.ts\n// @require core/unique.ts\n// @require core/variables.ts\n// @require collection/each.ts\n// @require ./children.ts\n// @require ./not.ts\n// @require ./parent.ts\n\ninterface Cash {\n  siblings ( comparator?: Comparator ): Cash;\n}\n\nfn.siblings = function ( this: Cash, comparator?: Comparator ) {\n\n  return filtered ( cash ( unique ( pluck ( this, ele => cash ( ele ).parent ().children ().not ( ele ) ) ) ), comparator );\n\n};\n\n\n// @require core/cash.ts\n// @require core/pluck.ts\n// @require core/unique.ts\n// @require core/find.ts\n// @require core/variables.ts\n\ninterface Cash {\n  find ( selector: string ): Cash;\n}\n\nfn.find = function ( this: Cash, selector: string ) {\n\n  return cash ( unique ( pluck ( this, ele => find ( selector, ele ) ) ) );\n\n};\n\n\n// @require core/variables.ts\n// @require collection/filter.ts\n// @require traversal/find.ts\n\nconst HTMLCDATARe = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\nconst scriptTypeRe = /^$|^module$|\\/(java|ecma)script/i;\nconst scriptAttributes: ('type' | 'src' | 'nonce' | 'noModule')[] = ['type', 'src', 'nonce', 'noModule'];\n\nfunction evalScripts ( node: Node, doc: Document ): void {\n\n  const collection = cash ( node );\n\n  collection.filter ( 'script' ).add ( collection.find ( 'script' ) ).each ( ( i, ele: HTMLScriptElement ) => {\n\n    if ( scriptTypeRe.test ( ele.type ) && docEle.contains ( ele ) ) { // The script type is supported // The element is attached to the DOM // Using `documentElement` for broader browser support\n\n      const script = createElement ( 'script' );\n\n      script.text = ele.textContent.replace ( HTMLCDATARe, '' );\n\n      each ( scriptAttributes, ( i, attr ) => {\n\n        if ( ele[attr] ) script[attr] = ele[attr];\n\n      });\n\n      doc.head.insertBefore ( script, null );\n      doc.head.removeChild ( script );\n\n    }\n\n  });\n\n}\n\n\n// @require ./eval_scripts.ts\n\nfunction insertElement ( anchor: EleLoose, target: EleLoose, left?: boolean, inside?: boolean, evaluate?: boolean ): void {\n\n  if ( inside ) { // prepend/append\n\n    anchor.insertBefore ( target, left ? anchor.firstChild : null );\n\n  } else { // before/after\n\n    if ( anchor.nodeName === 'HTML' ) {\n\n      anchor.parentNode.replaceChild ( target, anchor );\n\n    } else {\n\n      anchor.parentNode.insertBefore ( target, left ? anchor : anchor.nextSibling );\n\n    }\n\n  }\n\n  if ( evaluate ) {\n\n    evalScripts ( target, anchor.ownerDocument );\n\n  }\n\n}\n\n\n// @require ./insert_element.ts\n\nfunction insertSelectors<T extends ArrayLike<EleLoose> = ArrayLike<EleLoose>> ( selectors: ArrayLike<Selector>, anchors: T, inverse?: boolean, left?: boolean, inside?: boolean, reverseLoop1?: boolean, reverseLoop2?: boolean, reverseLoop3?: boolean ): T {\n\n  each ( selectors, ( si, selector: Selector ) => {\n\n    each ( cash ( selector ), ( ti, target ) => {\n\n      each ( cash ( anchors ), ( ai, anchor ) => {\n\n        const anchorFinal = inverse ? target : anchor;\n        const targetFinal = inverse ? anchor : target;\n        const indexFinal = inverse ? ti : ai;\n\n        insertElement ( anchorFinal, !indexFinal ? targetFinal : targetFinal.cloneNode ( true ), left, inside, !indexFinal );\n\n      }, reverseLoop3 );\n\n    }, reverseLoop2 );\n\n  }, reverseLoop1 );\n\n  return anchors;\n\n}\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  after ( ...selectors: Selector[] ): this;\n}\n\nfn.after = function ( this: Cash ) {\n\n  return insertSelectors ( arguments, this, false, false, false, true, true );\n\n};\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  append ( ...selectors: Selector[] ): this;\n}\n\nfn.append = function ( this: Cash ) {\n\n  return insertSelectors ( arguments, this, false, false, true );\n\n};\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require manipulation/append.ts\n// @require manipulation/empty.ts\n\ninterface Cash {\n  html (): string;\n  html ( html: string ): this;\n}\n\nfunction html ( this: Cash ): string;\nfunction html ( this: Cash, html: string ): Cash;\nfunction html ( this: Cash, html?: string ) {\n\n  if ( !arguments.length ) return this[0] && this[0].innerHTML;\n\n  if ( isUndefined ( html ) ) return this;\n\n  const hasScript = /<script[\\s>]/.test ( html );\n\n  return this.each ( ( i, ele ) => {\n\n    if ( !isElement ( ele ) ) return;\n\n    if ( hasScript ) {\n\n      cash ( ele ).empty ().append ( html );\n\n    } else {\n\n      ele.innerHTML = html;\n\n    }\n\n  });\n\n}\n\nfn.html = html;\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  appendTo ( selector: Selector ): this;\n}\n\nfn.appendTo = function ( this: Cash, selector: Selector ) {\n\n  return insertSelectors ( arguments, this, true, false, true );\n\n};\n\n\n// @require core/cash.ts\n// @require collection/first.ts\n// @require manipulation/append_to.ts\n\ninterface Cash {\n  wrapInner ( selector?: Selector ): this;\n}\n\nfn.wrapInner = function ( this: Cash, selector?: Selector ) {\n\n  return this.each ( ( i, ele ) => {\n\n    const $ele = cash ( ele );\n    const contents = $ele.contents ();\n\n    contents.length ? contents.wrapAll ( selector ) : $ele.append ( selector );\n\n  });\n\n};\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  before ( ...selectors: Selector[] ): this;\n}\n\nfn.before = function ( this: Cash ) {\n\n  return insertSelectors ( arguments, this, false, true );\n\n};\n\n\n// @require core/cash.ts\n// @require collection/first.ts\n// @require manipulation/append_to.ts\n// @require manipulation/before.ts\n\ninterface Cash {\n  wrapAll ( selector?: Selector ): this;\n}\n\nfn.wrapAll = function ( this: Cash, selector?: Selector ) {\n\n  let structure = cash ( selector );\n  let wrapper: Element = structure[0];\n\n  while ( wrapper.children.length ) wrapper = wrapper.firstElementChild;\n\n  this.first ().before ( structure );\n\n  return this.appendTo ( wrapper );\n\n};\n\n\n// @require core/cash.ts\n// @require collection/each.ts\n// @require ./wrap_all.ts\n\ninterface Cash {\n  wrap ( selector?: Selector ): this;\n}\n\nfn.wrap = function ( this: Cash, selector?: Selector ) {\n\n  return this.each ( ( i, ele ) => {\n\n    const wrapper = cash ( selector )[0];\n\n    cash ( ele ).wrapAll ( !i ? wrapper : wrapper.cloneNode ( true ) );\n\n  });\n\n};\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  insertAfter ( selector: Selector ): this;\n}\n\nfn.insertAfter = function ( this: Cash, selector: Selector ) {\n\n  return insertSelectors ( arguments, this, true, false, false, false, false, true );\n\n};\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  insertBefore ( selector: Selector ): this;\n}\n\nfn.insertBefore = function ( this: Cash, selector: Selector ) {\n\n  return insertSelectors ( arguments, this, true, true );\n\n};\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  prepend ( ...selectors: Selector[] ): this;\n}\n\nfn.prepend = function ( this: Cash ) {\n\n  return insertSelectors ( arguments, this, false, true, true, true, true );\n\n};\n\n\n// @require core/cash.ts\n// @require ./helpers/insert_selectors.ts\n\ninterface Cash {\n  prependTo ( selector: Selector ): this;\n}\n\nfn.prependTo = function ( this: Cash, selector: Selector ) {\n\n  return insertSelectors ( arguments, this, true, true, true, false, false, true );\n\n};\n\n\n// @require core/cash.ts\n// @require core/pluck.ts\n// @require core/unique.ts\n// @require collection/each.ts\n\ninterface Cash {\n  contents (): Cash;\n}\n\nfn.contents = function ( this: Cash ) {\n\n  return cash ( unique ( pluck ( this, ele => ele.tagName === 'IFRAME' ? [ele.contentDocument] : ( ele.tagName === 'TEMPLATE' ? ele.content.childNodes : ele.childNodes ) ) ) );\n\n};\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require core/pluck.ts\n// @require core/unique.ts\n\ninterface Cash {\n  next ( comparator?: Comparator, _all?: boolean, _until?: Comparator ): Cash;\n}\n\nfn.next = function ( this: Cash, comparator?: Comparator, _all?: boolean, _until?: Comparator ) {\n\n  return filtered ( cash ( unique ( pluck ( this, 'nextElementSibling', _all, _until ) ) ), comparator );\n\n};\n\n\n// @require ./next.ts\n\ninterface Cash {\n  nextAll ( comparator?: Comparator): Cash;\n}\n\nfn.nextAll = function ( this: Cash, comparator?: Comparator ) {\n\n  return this.next ( comparator, true );\n\n};\n\n\n// @require ./next.ts\n\ninterface Cash {\n  nextUntil ( until?: Comparator, comparator?: Comparator): Cash;\n}\n\nfn.nextUntil = function ( this: Cash, until?: Comparator, comparator?: Comparator ) {\n\n  return this.next ( comparator, true, until );\n\n};\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require core/matches.ts\n// @require core/unique.ts\n// @require core/variables.ts\n// @require collection/each.ts\n\ninterface Cash {\n  parents ( comparator?: Comparator, _until?: Comparator ): Cash;\n}\n\nfn.parents = function ( this: Cash, comparator?: Comparator, _until?: Comparator ) {\n\n  return filtered ( cash ( unique ( pluck ( this, 'parentElement', true, _until ) ) ), comparator );\n\n};\n\n\n// @require ./parents.ts\n\ninterface Cash {\n  parentsUntil ( until?: Comparator, comparator?: Comparator): Cash;\n}\n\nfn.parentsUntil = function ( this: Cash, until?: Comparator, comparator?: Comparator ) {\n\n  return this.parents ( comparator, until );\n\n};\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require core/pluck.ts\n// @require core/unique.ts\n\ninterface Cash {\n  prev ( comparator?: Comparator, _all?: boolean, _until?: Comparator ): Cash;\n}\n\nfn.prev = function ( this: Cash, comparator?: Comparator, _all?: boolean, _until?: Comparator ) {\n\n  return filtered ( cash ( unique ( pluck ( this, 'previousElementSibling', _all, _until ) ) ), comparator );\n\n};\n\n\n// @require ./prev.ts\n\ninterface Cash {\n  prevAll ( comparator?: Comparator ): Cash;\n}\n\nfn.prevAll = function ( this: Cash, comparator?: Comparator ) {\n\n  return this.prev ( comparator, true );\n\n};\n\n\n// @require ./prev.ts\n\ninterface Cash {\n  prevUntil ( until?: Comparator, comparator?: Comparator ): Cash;\n}\n\nfn.prevUntil = function ( this: Cash, until?: Comparator, comparator?: Comparator ) {\n\n  return this.prev ( comparator, true, until );\n\n};\n\n\n// @require core/cash.ts\n// @require core/variables.ts\n\ntype MapCallback<T> = ( this: T, index: number, ele: T ) => Ele;\n\ninterface Cash {\n  map ( callback: MapCallback<EleLoose> ): Cash;\n}\n\nfn.map = function ( this: Cash, callback: MapCallback<EleLoose> ) {\n\n  return cash ( concat.apply ( [], map.call ( this, ( ele: EleLoose, i: number ) => callback.call ( ele, i, ele ) ) ) );\n\n};\n\n\n// @require core/cash.ts\n// @require collection/map.ts\n\ninterface Cash {\n  clone (): this;\n}\n\nfn.clone = function ( this: Cash ) {\n\n  return this.map ( ( i, ele ) => ele.cloneNode ( true ) );\n\n};\n\n\n// @require core/cash.ts\n// @require collection/map.ts\n// @require css/helpers/compute_style.ts\n\ninterface Cash {\n  offsetParent (): Cash;\n}\n\nfn.offsetParent = function ( this: Cash ) {\n\n  return this.map ( ( i, ele ) => {\n\n    let offsetParent = ele.offsetParent;\n\n    while ( offsetParent && computeStyle ( offsetParent, 'position' ) === 'static' ) {\n\n      offsetParent = offsetParent.offsetParent;\n\n    }\n\n    return offsetParent || docEle;\n\n  });\n\n};\n\n\n// @require core/cash.ts\n// @require core/variables.ts\n\ninterface Cash {\n  slice ( start?: number, end?: number ): Cash;\n}\n\nfn.slice = function ( this: Cash, start?: number, end?: number ) {\n\n  return cash ( slice.call ( this, start, end ) );\n\n};\n\n\n// @require ./cash.ts\n\nconst dashAlphaRe = /-([a-z])/g;\n\nfunction camelCase ( str: string ): string {\n\n  return str.replace ( dashAlphaRe, ( match: string, letter: string ) => letter.toUpperCase () );\n\n}\n\n\n// @require core/cash.ts\n// @require core/variables.ts\n\ninterface Cash {\n  ready ( callback: Function ): this;\n}\n\nfn.ready = function ( this: Cash, callback: ( $: typeof cash ) => any ) {\n\n  const cb = () => setTimeout ( callback, 0, cash );\n\n  if ( doc.readyState !== 'loading' ) {\n\n    cb ();\n\n  } else {\n\n    doc.addEventListener ( 'DOMContentLoaded', cb );\n\n  }\n\n  return this;\n\n};\n\n\n// @require core/cash.ts\n\ninterface Cash {\n  unwrap (): this;\n}\n\nfn.unwrap = function ( this: Cash ) {\n\n  this.parent ().each ( ( i, ele ) => {\n\n    if ( ele.tagName === 'BODY' ) return;\n\n    const $ele = cash ( ele );\n\n    $ele.replaceWith ( $ele.children () );\n\n  });\n\n  return this;\n\n};\n\n\n// @require core/cash.ts\n// @require core/variables.ts\n\ninterface Cash {\n  offset (): undefined | {\n    top: number,\n    left: number\n  };\n}\n\nfn.offset = function ( this: Cash ) {\n\n  const ele = this[0];\n\n  if ( !ele ) return;\n\n  const rect = ele.getBoundingClientRect ();\n\n  return {\n    top: rect.top + win.pageYOffset,\n    left: rect.left + win.pageXOffset\n  };\n\n};\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require css/helpers/compute_style.ts\n// @require css/helpers/compute_style_int.ts\n// @require ./offset.ts\n\ninterface Cash {\n  position (): undefined | {\n    top: number,\n    left: number\n  };\n}\n\nfn.position = function ( this: Cash ) {\n\n  const ele = this[0];\n\n  if ( !ele ) return;\n\n  const isFixed = ( computeStyle ( ele, 'position' ) === 'fixed' );\n  const offset = isFixed ? ele.getBoundingClientRect () : this.offset ();\n\n  if ( !isFixed ) {\n\n    const doc = ele.ownerDocument;\n\n    let offsetParent = ele.offsetParent || doc.documentElement;\n\n    while ( ( offsetParent === doc.body || offsetParent === doc.documentElement ) && computeStyle ( offsetParent, 'position' ) === 'static' ) {\n\n      offsetParent = offsetParent.parentNode;\n\n    }\n\n    if ( offsetParent !== ele && isElement ( offsetParent ) ) {\n\n      const parentOffset = cash ( offsetParent ).offset ();\n\n      offset.top -= parentOffset.top + computeStyleInt ( offsetParent, 'borderTopWidth' );\n      offset.left -= parentOffset.left + computeStyleInt ( offsetParent, 'borderLeftWidth' );\n\n    }\n\n  }\n\n  return {\n    top: offset.top - computeStyleInt ( ele, 'marginTop' ),\n    left: offset.left - computeStyleInt ( ele, 'marginLeft' )\n  };\n\n};\n\n\nconst propMap: Record<string, string> = {\n  /* GENERAL */\n  class: 'className',\n  contenteditable: 'contentEditable',\n  /* LABEL */\n  for: 'htmlFor',\n  /* INPUT */\n  readonly: 'readOnly',\n  maxlength: 'maxLength',\n  tabindex: 'tabIndex',\n  /* TABLE */\n  colspan: 'colSpan',\n  rowspan: 'rowSpan',\n  /* IMAGE */\n  usemap: 'useMap'\n};\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require ./helpers/variables.ts\n\ninterface Cash {\n  prop ( prop: string ): any;\n  prop ( prop: string, value: any ): this;\n  prop ( props: Record<string, any> ): this;\n}\n\nfn.prop = function ( this: Cash, prop: string | Record<string, any>, value?: any ) {\n\n  if ( !prop ) return;\n\n  if ( isString ( prop ) ) {\n\n    prop = propMap[prop] || prop;\n\n    if ( arguments.length < 2 ) return this[0] && this[0][prop];\n\n    return this.each ( ( i, ele ) => { ele[prop] = value } );\n\n  }\n\n  for ( const key in prop ) {\n\n    this.prop ( key, prop[key] );\n\n  }\n\n  return this;\n\n};\n\n\n// @require core/cash.ts\n// @require collection/each.ts\n// @require ./helpers/variables.ts\n\ninterface Cash {\n  removeProp ( prop: string ): this;\n}\n\nfn.removeProp = function ( this: Cash, prop: string ) {\n\n  return this.each ( ( i, ele ) => { delete ele[propMap[prop] || prop] } );\n\n};\n\n\nconst cssVariableRe = /^--/;\n\n\n// @require ./variables.ts\n\nfunction isCSSVariable ( prop: string ): boolean {\n\n  return cssVariableRe.test ( prop );\n\n}\n\n\n// @require core/camel_case.ts\n// @require core/cash.ts\n// @require core/each.ts\n// @require core/variables.ts\n// @require ./is_css_variable.ts\n\nconst prefixedProps: { [prop: string]: string } = {};\nconst {style} = div;\nconst vendorsPrefixes = ['webkit', 'moz', 'ms'];\n\nfunction getPrefixedProp ( prop: string, isVariable: boolean = isCSSVariable ( prop ) ): string {\n\n  if ( isVariable ) return prop;\n\n  if ( !prefixedProps[prop] ) {\n\n    const propCC = camelCase ( prop );\n    const propUC = `${propCC[0].toUpperCase ()}${propCC.slice ( 1 )}`;\n    const props = ( `${propCC} ${vendorsPrefixes.join ( `${propUC} ` )}${propUC}` ).split ( ' ' );\n\n    each ( props, ( i, p ) => {\n\n      if ( p in style ) {\n\n        prefixedProps[prop] = p;\n\n        return false;\n\n      }\n\n    });\n\n  }\n\n  return prefixedProps[prop];\n\n}\n\n\n// @require core/type_checking.ts\n// @require ./is_css_variable.ts\n\nconst numericProps: { [prop: string]: true | undefined } = {\n  animationIterationCount: true,\n  columnCount: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  gridArea: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnStart: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowStart: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  widows: true,\n  zIndex: true\n};\n\nfunction getSuffixedValue ( prop: string, value: number | string, isVariable: boolean = isCSSVariable ( prop ) ): string {\n\n  return !isVariable && !numericProps[prop] && isNumeric ( value ) ? `${value}px` : value;\n\n}\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require ./helpers/compute_style.ts\n// @require ./helpers/get_prefixed_prop.ts\n// @require ./helpers/get_suffixed_value.ts\n// @require ./helpers/is_css_variable.ts\n\ninterface Cash {\n  css ( prop: string ): string | undefined;\n  css ( prop: string, value: number | string ): this;\n  css ( props: Record<string, number | string> ): this;\n}\n\nfunction css ( this: Cash, prop: string ): string | undefined;\nfunction css ( this: Cash, prop: string, value: number | string ): Cash;\nfunction css ( this: Cash, prop: Record<string, number | string> ): Cash;\nfunction css ( this: Cash, prop: string | Record<string, number | string>, value?: number | string ) {\n\n  if ( isString ( prop ) ) {\n\n    const isVariable = isCSSVariable ( prop );\n\n    prop = getPrefixedProp ( prop, isVariable );\n\n    if ( arguments.length < 2 ) return this[0] && computeStyle ( this[0], prop, isVariable );\n\n    if ( !prop ) return this;\n\n    value = getSuffixedValue ( prop, value, isVariable );\n\n    return this.each ( ( i, ele ) => {\n\n      if ( !isElement ( ele ) ) return;\n\n      if ( isVariable ) {\n\n        ele.style.setProperty ( prop, value );\n\n      } else {\n\n        ele.style[prop] = value;\n\n      }\n\n    });\n\n  }\n\n  for ( const key in prop ) {\n\n    this.css ( key, prop[key] );\n\n  }\n\n  return this;\n\n};\n\nfn.css = css;\n\n\nfunction attempt<T, U> ( fn: (( arg?: U ) => T), arg?: U ): T | U {\n\n  try {\n\n    return fn ( arg );\n\n  } catch {\n\n    return arg;\n\n  }\n\n}\n\n\n// @require core/attempt.ts\n// @require core/camel_case.ts\n\nconst JSONStringRe = /^\\s+|\\s+$/;\n\nfunction getData ( ele: EleLoose, key: string ): any {\n\n  const value = ele.dataset[key] || ele.dataset[camelCase ( key )];\n\n  if ( JSONStringRe.test ( value ) ) return value;\n\n  return attempt ( JSON.parse, value );\n\n}\n\n\n// @require core/attempt.ts\n// @require core/camel_case.ts\n\nfunction setData ( ele: EleLoose, key: string, value: any ): void {\n\n  value = attempt ( JSON.stringify, value );\n\n  ele.dataset[camelCase ( key )] = value;\n\n}\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require ./helpers/get_data.ts\n// @require ./helpers/set_data.ts\n\ninterface Cash {\n  data (): Record<string, any> | undefined;\n  data ( name: string ): any;\n  data ( name: string, value: any ): this;\n  data ( datas: Record<string, any> ): this;\n}\n\nfunction data ( this: Cash ): Record<string, any> | undefined;\nfunction data ( this: Cash, name: string ): any;\nfunction data ( this: Cash, name: string, value: any ): Cash;\nfunction data ( this: Cash, name: Record<string, any> ): Cash;\nfunction data ( this: Cash, name?: string | Record<string, any>, value?: any ) {\n\n  if ( !name ) {\n\n    if ( !this[0] ) return;\n\n    const datas: { [data: string]: any } = {};\n\n    for ( const key in this[0].dataset ) {\n\n      datas[key] = getData ( this[0], key );\n\n    }\n\n    return datas;\n\n  }\n\n  if ( isString ( name ) ) {\n\n    if ( arguments.length < 2 ) return this[0] && getData ( this[0], name );\n\n    if ( isUndefined ( value ) ) return this;\n\n    return this.each ( ( i, ele ) => { setData ( ele, name, value ) } );\n\n  }\n\n  for ( const key in name ) {\n\n    this.data ( key, name[key] );\n\n  }\n\n  return this;\n\n}\n\nfn.data = data;\n\n\nfunction getDocumentDimension ( doc: Document, dimension: 'Width' | 'Height' ): number {\n\n  const docEle = doc.documentElement;\n\n  return Math.max (\n    doc.body[`scroll${dimension}`],\n    docEle[`scroll${dimension}`],\n    doc.body[`offset${dimension}`],\n    docEle[`offset${dimension}`],\n    docEle[`client${dimension}`]\n  );\n\n}\n\n\n// @require core/cash.ts\n// @require core/each.ts\n// @require core/type_checking.ts\n// @require core/variables.ts\n// @require ./helpers/get_document_dimension.ts\n\ninterface Cash {\n  innerWidth (): number | undefined;\n  innerHeight (): number | undefined;\n  outerWidth ( includeMargins?: boolean ): number;\n  outerHeight ( includeMargins?: boolean ): number;\n}\n\neach ( [true, false], ( i, outer?: boolean ) => {\n\n  each ( ['Width', 'Height'], ( i, prop: 'Width' | 'Height' ) => {\n\n    const name: 'outerWidth' | 'innerHeight' = `${outer ? 'outer' : 'inner'}${prop}`;\n\n    fn[name] = function ( this: Cash, includeMargins?: boolean ) {\n\n      if ( !this[0] ) return;\n\n      if ( isWindow ( this[0] ) ) return outer ? this[0][`inner${prop}`] : this[0].document.documentElement[`client${prop}`];\n\n      if ( isDocument ( this[0] ) ) return getDocumentDimension ( this[0], prop );\n\n      return this[0][`${outer ? 'offset' : 'client'}${prop}`] + ( includeMargins && outer ? computeStyleInt ( this[0], `margin${ i ? 'Top' : 'Left' }` ) + computeStyleInt ( this[0], `margin${ i ? 'Bottom' : 'Right' }` ) : 0 );\n\n    };\n\n  });\n\n});\n\n\n// @require core/cash.ts\n// @require core/each.ts\n// @require core/type_checking.ts\n// @require core/variables.ts\n// @require css/helpers/compute_style.ts\n// @require css/helpers/get_suffixed_value.ts\n// @require ./helpers/get_extra_space.ts\n// @require ./helpers/get_document_dimension.ts\n\ninterface Cash {\n  width (): number;\n  width ( value: number | string ): this;\n  height (): number;\n  height ( value: number | string ): this;\n}\n\neach ( ['Width', 'Height'], ( index: number, prop: 'Width' | 'Height' ) => {\n\n  const propLC = prop.toLowerCase ();\n\n  fn[propLC] = function ( this: Cash, value?: number | string ) {\n\n    if ( !this[0] ) return isUndefined ( value ) ? undefined : this;\n\n    if ( !arguments.length ) {\n\n      if ( isWindow ( this[0] ) ) return this[0].document.documentElement[`client${prop}`];\n\n      if ( isDocument ( this[0] ) ) return getDocumentDimension ( this[0], prop );\n\n      return this[0].getBoundingClientRect ()[propLC] - getExtraSpace ( this[0], !index );\n\n    }\n\n    const valueNumber = parseInt ( value, 10 );\n\n    return this.each ( ( i, ele ) => {\n\n      if ( !isElement ( ele ) ) return;\n\n      const boxSizing = computeStyle ( ele, 'boxSizing' );\n\n      ele.style[propLC] = getSuffixedValue ( propLC, valueNumber + ( boxSizing === 'border-box' ? getExtraSpace ( ele, !index ) : 0 ) );\n\n    });\n\n  };\n\n});\n\n\nconst displayProperty = '___cd';\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require css/helpers/compute_style.ts\n// @require ./helpers/get_default_display.ts\n// @require ./helpers/is_hidden.ts\n// @require ./helpers/variables.ts\n\ninterface Cash {\n  toggle ( force?: boolean ): this;\n}\n\nfn.toggle = function ( this: Cash, force?: boolean ) {\n\n  return this.each ( ( i, ele ) => {\n\n    if ( !isElement ( ele ) ) return;\n\n    const hidden = isHidden ( ele );\n    const show = isUndefined ( force ) ? hidden : force;\n\n    if ( show ) {\n\n      ele.style.display = ele[displayProperty] || '';\n\n      if ( isHidden ( ele ) ) {\n\n        ele.style.display = getDefaultDisplay ( ele.tagName );\n\n      }\n\n    } else if ( !hidden ) {\n\n      ele[displayProperty] = computeStyle ( ele, 'display' );\n\n      ele.style.display = 'none';\n\n    }\n\n  });\n\n};\n\n\n// @require core/cash.ts\n// @require ./toggle.ts\n\ninterface Cash {\n  hide (): this;\n}\n\nfn.hide = function ( this: Cash ) {\n\n  return this.toggle ( false );\n\n};\n\n\n// @require core/cash.ts\n// @require ./toggle.ts\n\ninterface Cash {\n  show (): this;\n}\n\nfn.show = function ( this: Cash ) {\n\n  return this.toggle ( true );\n\n};\n\n\nconst eventsNamespace = '___ce';\nconst eventsNamespacesSeparator = '.';\nconst eventsFocus: { [event: string]: string | undefined } = { focus: 'focusin', blur: 'focusout' };\nconst eventsHover: { [event: string]: string | undefined } = { mouseenter: 'mouseover', mouseleave: 'mouseout' };\nconst eventsMouseRe = /^(mouse|pointer|contextmenu|drag|drop|click|dblclick)/i;\n\n\n// @require ./variables.ts\n\nfunction getEventNameBubbling ( name: string ): string {\n\n  return eventsHover[name] || eventsFocus[name] || name;\n\n}\n\n\n// @require ./variables.ts\n\nfunction parseEventName ( eventName: string ): [string, string[]] {\n\n  const parts = eventName.split ( eventsNamespacesSeparator );\n\n  return [parts[0], parts.slice ( 1 ).sort ()]; // [name, namespace[]]\n\n}\n\n\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require core/variables.ts\n// @require collection/each.ts\n// @require ./helpers/get_event_name_bubbling.ts\n// @require ./helpers/parse_event_name.ts\n// @require ./helpers/variables.ts\n\ninterface Cash {\n  trigger ( event: Event | string, data?: any ): this;\n}\n\nfn.trigger = function ( this: Cash, event: Event | string, data?: any ) {\n\n  if ( isString ( event ) ) {\n\n    const [nameOriginal, namespaces] = parseEventName ( event );\n    const name = getEventNameBubbling ( nameOriginal );\n\n    if ( !name ) return this;\n\n    const type = eventsMouseRe.test ( name ) ? 'MouseEvents' : 'HTMLEvents';\n\n    event = doc.createEvent ( type );\n    event.initEvent ( name, true, true );\n    event.namespace = namespaces.join ( eventsNamespacesSeparator );\n    event.___ot = nameOriginal;\n\n  }\n\n  event.___td = data;\n\n  const isEventFocus = ( event.___ot in eventsFocus );\n\n  return this.each ( ( i, ele ) => {\n\n    if ( isEventFocus && isFunction ( ele[event.___ot] ) ) {\n\n      ele[`___i${event.type}`] = true; // Ensuring the native event is ignored\n\n      ele[event.___ot]();\n\n      ele[`___i${event.type}`] = false; // Ensuring the custom event is not ignored\n\n    }\n\n    ele.dispatchEvent ( event );\n\n  });\n\n};\n\n\n// @require ./variables.ts\n\nfunction getEventsCache ( ele: EleLoose ): { [event: string]: [string[], string, EventCallback][] } {\n\n  return ele[eventsNamespace] = ( ele[eventsNamespace] || {} );\n\n}\n\n\n// @require core/guid.ts\n// @require events/helpers/get_events_cache.ts\n\nfunction addEvent ( ele: EleLoose, name: string, namespaces: string[], selector: string, callback: EventCallback ): void {\n\n  const eventCache = getEventsCache ( ele );\n\n  eventCache[name] = ( eventCache[name] || [] );\n  eventCache[name].push ([ namespaces, selector, callback ]);\n\n  ele.addEventListener ( name, callback );\n\n}\n\n\nfunction hasNamespaces ( ns1: string[], ns2?: string[] ): boolean {\n\n  return !ns2 || !some.call ( ns2, ( ns: string ) => ns1.indexOf ( ns ) < 0 );\n\n}\n\n\n// @require ./get_events_cache.ts\n// @require ./has_namespaces.ts\n// @require ./parse_event_name.ts\n\nfunction removeEvent ( ele: EleLoose, name?: string, namespaces?: string[], selector?: string, callback?: EventCallback ): void {\n\n  const cache = getEventsCache ( ele );\n\n  if ( !name ) {\n\n    for ( name in cache ) {\n\n      removeEvent ( ele, name, namespaces, selector, callback );\n\n    }\n\n  } else if ( cache[name] ) {\n\n    cache[name] = cache[name].filter ( ([ ns, sel, cb ]) => {\n\n      if ( ( callback && cb.guid !== callback.guid ) || !hasNamespaces ( ns, namespaces ) || ( selector && selector !== sel ) ) return true;\n\n      ele.removeEventListener ( name, cb );\n\n    });\n\n  }\n\n}\n\n\n// @require core/cash.ts\n// @require core/each.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require ./helpers/get_event_name_bubbling.ts\n// @require ./helpers/parse_event_name.ts\n// @require ./helpers/remove_event.ts\n\ninterface Cash {\n  off (): this;\n  off ( events: string ): this;\n  off ( events: Record<string, EventCallback> ): this;\n  off ( events: string, callback: EventCallback ): this;\n  off ( events: string, selector: string, callback: EventCallback ): this;\n}\n\nfn.off = function ( this: Cash, eventFullName?: string | Record<string, EventCallback>, selector?: string | EventCallback, callback?: EventCallback ) {\n\n  if ( isUndefined ( eventFullName ) ) {\n\n    this.each ( ( i, ele ) => {\n\n      if ( !isElement ( ele ) && !isDocument ( ele ) && !isWindow ( ele ) ) return;\n\n      removeEvent ( ele );\n\n    });\n\n  } else if ( !isString ( eventFullName ) ) {\n\n    for ( const key in eventFullName ) {\n\n      this.off ( key, eventFullName[key] );\n\n    }\n\n  } else {\n\n    if ( isFunction ( selector ) ) {\n\n      callback = selector;\n      selector = '';\n\n    }\n\n    each ( getSplitValues ( eventFullName ), ( i, eventFullName ) => {\n\n      const [nameOriginal, namespaces] = parseEventName ( eventFullName );\n      const name = getEventNameBubbling ( nameOriginal );\n\n      this.each ( ( i, ele ) => {\n\n        if ( !isElement ( ele ) && !isDocument ( ele ) && !isWindow ( ele ) ) return;\n\n        removeEvent ( ele, name, namespaces, selector, callback );\n\n      });\n\n    });\n\n  }\n\n  return this;\n\n};\n\n\n// @require core/cash.ts\n// @require core/filtered.ts\n// @require events/off.ts\n// @require ./detach.ts\n\ninterface Cash {\n  remove ( comparator?: Comparator ): this;\n}\n\nfn.remove = function ( this: Cash, comparator?: Comparator ) {\n\n  filtered ( this, comparator ).detach ().off ();\n\n  return this;\n\n};\n\n\n// @require core/cash.ts\n// @require ./before.ts\n// @require ./remove.ts\n\ninterface Cash {\n  replaceWith ( selector: Selector ): this;\n}\n\nfn.replaceWith = function ( this: Cash, selector: Selector ) {\n\n  return this.before ( selector ).remove ();\n\n};\n\n\n// @require core/cash.ts\n// @require ./replace_with.ts\n\ninterface Cash {\n  replaceAll ( selector: Selector ): this;\n}\n\nfn.replaceAll = function ( this: Cash, selector: Selector ) {\n\n  cash ( selector ).replaceWith ( this );\n\n  return this;\n\n};\n\n\n// @require core/cash.ts\n// @require core/get_split_values.ts\n// @require core/guid.ts\n// @require core/matches.ts\n// @require core/type_checking.ts\n// @require collection/each.ts\n// @require ./helpers/variables.ts\n// @require ./helpers/add_event.ts\n// @require ./helpers/get_event_name_bubbling.ts\n// @require ./helpers/has_namespaces.ts\n// @require ./helpers/parse_event_name.ts\n// @require ./helpers/remove_event.ts\n\ninterface Cash {\n  on ( events: Record<string, EventCallback> ): this;\n  on ( events: Record<string, EventCallback>, selector: string ): this;\n  on ( events: Record<string, EventCallback>, data: any ): this;\n  on ( events: Record<string, EventCallback>, selector: string | null | undefined, data: any ): this;\n  on ( events: string, callback: EventCallback ): this;\n  on ( events: string, selector: string, callback: EventCallback ): this;\n  on ( events: string, data: any, callback: EventCallback ): this;\n  on ( events: string, selector: string | null | undefined, data: any, callback: EventCallback, _one?: boolean ): this;\n}\n\nfunction on ( this: Cash, eventFullName: Record<string, EventCallback> ): Cash;\nfunction on ( this: Cash, eventFullName: Record<string, EventCallback>, selector: string ): Cash;\nfunction on ( this: Cash, eventFullName: Record<string, EventCallback>, data: any ): Cash;\nfunction on ( this: Cash, eventFullName: Record<string, EventCallback>, selector: string | null | undefined, data: any ): Cash;\nfunction on ( this: Cash, eventFullName: string, callback: EventCallback ): Cash;\nfunction on ( this: Cash, eventFullName: string, selector: string, callback: EventCallback ): Cash;\nfunction on ( this: Cash, eventFullName: string, data: any, callback: EventCallback ): Cash;\nfunction on ( this: Cash, eventFullName: string, selector: string | null | undefined, data: any, callback: EventCallback, _one?: boolean ): Cash;\nfunction on ( this: Cash, eventFullName: Record<string, EventCallback> | string, selector?: any, data?: any, callback?: EventCallback, _one?: boolean ) {\n\n  if ( !isString ( eventFullName ) ) {\n\n    for ( const key in eventFullName ) {\n\n      this.on ( key, selector, data, eventFullName[key], _one );\n\n    }\n\n    return this;\n\n  }\n\n  if ( !isString ( selector ) ) {\n\n    if ( isUndefined ( selector ) || isNull ( selector ) ) {\n\n      selector = '';\n\n    } else if ( isUndefined ( data ) ) {\n\n      data = selector;\n      selector = '';\n\n    } else {\n\n      callback = data;\n      data = selector;\n      selector = '';\n\n    }\n\n  }\n\n  if ( !isFunction ( callback ) ) {\n\n    callback = data;\n    data = undefined;\n\n  }\n\n  if ( !callback ) return this;\n\n  each ( getSplitValues ( eventFullName ), ( i, eventFullName ) => {\n\n    const [nameOriginal, namespaces] = parseEventName ( eventFullName );\n    const name = getEventNameBubbling ( nameOriginal );\n    const isEventHover = ( nameOriginal in eventsHover );\n    const isEventFocus = ( nameOriginal in eventsFocus );\n\n    if ( !name ) return;\n\n    this.each ( ( i, ele ) => {\n\n      if ( !isElement ( ele ) && !isDocument ( ele ) && !isWindow ( ele ) ) return;\n\n      const finalCallback = function ( event: Event ) {\n\n        if ( event.target[`___i${event.type}`] ) return event.stopImmediatePropagation (); // Ignoring native event in favor of the upcoming custom one\n\n        if ( event.namespace && !hasNamespaces ( namespaces, event.namespace.split ( eventsNamespacesSeparator ) ) ) return;\n\n        if ( !selector && ( ( isEventFocus && ( event.target !== ele || event.___ot === name ) ) || ( isEventHover && event.relatedTarget && ele.contains ( event.relatedTarget ) ) ) ) return;\n\n        let thisArg: EventTarget = ele;\n\n        if ( selector ) {\n\n          let target = event.target;\n\n          while ( !matches ( target, selector ) ) {\n\n            if ( target === ele ) return;\n\n            target = target.parentNode;\n\n            if ( !target ) return;\n\n          }\n\n          thisArg = target;\n\n        }\n\n        Object.defineProperty ( event, 'currentTarget', {\n          configurable: true,\n          get () { // We need to define a getter for this to work everywhere\n            return thisArg;\n          }\n        });\n\n        Object.defineProperty ( event, 'delegateTarget', {\n          configurable: true,\n          get () { // We need to define a getter for this to work everywhere\n            return ele;\n          }\n        });\n\n        Object.defineProperty ( event, 'data', {\n          configurable: true,\n          get () {\n            return data;\n          }\n        });\n\n        const returnValue = callback.call ( thisArg, event, event.___td );\n\n        if ( _one ) {\n\n          removeEvent ( ele, name, namespaces, selector, finalCallback );\n\n        }\n\n        if ( returnValue === false ) {\n\n          event.preventDefault ();\n          event.stopPropagation ();\n\n        }\n\n      };\n\n      finalCallback.guid = callback.guid = ( callback.guid || cash.guid++ );\n\n      addEvent ( ele, name, namespaces, selector, finalCallback );\n\n    });\n\n  });\n\n  return this;\n\n}\n\nfn.on = on;\n\n\n// @require core/cash.ts\n// @require ./on.ts\n\ninterface Cash {\n  one ( events: Record<string, EventCallback> ): this;\n  one ( events: Record<string, EventCallback>, selector: string ): this;\n  one ( events: Record<string, EventCallback>, data: any ): this;\n  one ( events: Record<string, EventCallback>, selector: string | null | undefined, data: any ): this;\n  one ( events: string, callback: EventCallback ): this;\n  one ( events: string, selector: string, callback: EventCallback ): this;\n  one ( events: string, data: any, callback: EventCallback ): this;\n  one ( events: string, selector: string | null | undefined, data: any, callback: EventCallback ): this;\n}\n\nfunction one ( this: Cash, eventFullName: Record<string, EventCallback> ): Cash;\nfunction one ( this: Cash, eventFullName: Record<string, EventCallback>, selector: string ): Cash;\nfunction one ( this: Cash, eventFullName: Record<string, EventCallback>, data: any ): Cash;\nfunction one ( this: Cash, eventFullName: Record<string, EventCallback>, selector: string | null | undefined, data: any ): Cash;\nfunction one ( this: Cash, eventFullName: string, callback: EventCallback ): Cash;\nfunction one ( this: Cash, eventFullName: string, selector: string, callback: EventCallback ): Cash;\nfunction one ( this: Cash, eventFullName: string, data: any, callback: EventCallback ): Cash;\nfunction one ( this: Cash, eventFullName: string, selector: string | null | undefined, data: any, callback: EventCallback ): Cash;\nfunction one ( this: Cash, eventFullName: Record<string, EventCallback> | string, selector?: any, data?: any, callback?: EventCallback ) {\n\n  return this.on ( eventFullName, selector, data, callback, true );\n\n};\n\nfn.one = one;\n\n\nconst queryEncodeCRLFRe = /\\r?\\n/g;\n\nfunction queryEncode ( prop: string, value: string ): string {\n\n  return `&${encodeURIComponent ( prop )}=${encodeURIComponent ( value.replace ( queryEncodeCRLFRe, '\\r\\n' ) )}`;\n\n}\n\n\n// @require core/cash.ts\n// @require core/each.ts\n// @require core/type_checking.ts\n// @require ./helpers/get_value.ts\n// @require ./helpers/query_encode.ts\n\ninterface Cash {\n  serialize (): string;\n}\n\nconst skippableRe = /file|reset|submit|button|image/i;\nconst checkableRe = /radio|checkbox/i;\n\nfn.serialize = function ( this: Cash ) {\n\n  let query = '';\n\n  this.each ( ( i, ele ) => {\n\n    each ( ele.elements || [ele], ( i, ele: EleLoose ) => {\n\n      if ( ele.disabled || !ele.name || ele.tagName === 'FIELDSET' || skippableRe.test ( ele.type ) || ( checkableRe.test ( ele.type ) && !ele.checked ) ) return;\n\n      const value = getValue ( ele );\n\n      if ( !isUndefined ( value ) ) {\n\n        const values = isArray ( value ) ? value : [value];\n\n        each ( values, ( i, value ) => {\n\n          query += queryEncode ( ele.name, value );\n\n        });\n\n      }\n\n    });\n\n  });\n\n  return query.slice ( 1 );\n\n};\n\n\n// @require core/types.ts\n// @require core/cash.ts\n// @require core/type_checking.ts\n// @require core/variables.ts\n// @require core/each.ts\n// @require core/extend.ts\n// @require core/find.ts\n// @require core/get_compare_function.ts\n// @require core/get_split_values.ts\n// @require core/guid.ts\n// @require core/parse_html.ts\n// @require core/unique.ts\n\n// @require attributes/add_class.ts\n// @require attributes/attr.ts\n// @require attributes/has_class.ts\n// @require attributes/prop.ts\n// @require attributes/remove_attr.ts\n// @require attributes/remove_class.ts\n// @require attributes/remove_prop.ts\n// @require attributes/toggle_class.ts\n\n// @require collection/add.ts\n// @require collection/each.ts\n// @require collection/eq.ts\n// @require collection/filter.ts\n// @require collection/first.ts\n// @require collection/get.ts\n// @require collection/index.ts\n// @require collection/last.ts\n// @require collection/map.ts\n// @require collection/slice.ts\n\n// @require css/css.ts\n\n// @require data/data.ts\n\n// @require dimensions/inner_outer.ts\n// @require dimensions/normal.ts\n\n// @require effects/hide.ts\n// @require effects/show.ts\n// @require effects/toggle.ts\n\n// @require events/off.ts\n// @require events/on.ts\n// @require events/one.ts\n// @require events/ready.ts\n// @require events/trigger.ts\n\n// @require forms/serialize.ts\n// @require forms/val.ts\n\n// @require manipulation/after.ts\n// @require manipulation/append.ts\n// @require manipulation/append_to.ts\n// @require manipulation/before.ts\n// @require manipulation/clone.ts\n// @require manipulation/detach.ts\n// @require manipulation/empty.ts\n// @require manipulation/html.ts\n// @require manipulation/insert_after.ts\n// @require manipulation/insert_before.ts\n// @require manipulation/prepend.ts\n// @require manipulation/prepend_to.ts\n// @require manipulation/remove.ts\n// @require manipulation/replace_all.ts\n// @require manipulation/replace_with.ts\n// @require manipulation/text.ts\n// @require manipulation/unwrap.ts\n// @require manipulation/wrap.ts\n// @require manipulation/wrap_all.ts\n// @require manipulation/wrap_inner.ts\n\n// @require offset/offset.ts\n// @require offset/offset_parent.ts\n// @require offset/position.ts\n\n// @require traversal/children.ts\n// @require traversal/closest.ts\n// @require traversal/contents.ts\n// @require traversal/find.ts\n// @require traversal/has.ts\n// @require traversal/is.ts\n// @require traversal/next.ts\n// @require traversal/next_all.ts\n// @require traversal/next_until.ts\n// @require traversal/not.ts\n// @require traversal/parent.ts\n// @require traversal/parents.ts\n// @require traversal/parents_until.ts\n// @require traversal/prev.ts\n// @require traversal/prev_all.ts\n// @require traversal/prev_until.ts\n// @require traversal/siblings.ts\n\n// @no-require extras/get_script.ts\n// @no-require extras/shorthands.ts\n\n\n// @require methods.ts\n\nexport default cash;\nexport {Cash, CashStatic, Ele as Element, Selector, Comparator, Context};\n\n","import * as L from \"leaflet\";\nimport { DownloadQueue } from \"./download-queue\";\nimport { OverpassLayer } from \"./overpass-layer\";\n\nfunction toOverpassString(bbox: L.LatLngBounds) {\n  const a = bbox.getSouthWest();\n  const b = bbox.getNorthEast();\n  return [\n    Math.round(a.lat * 1000) / 1000 + 0.0001,\n    Math.round(a.lng * 1000) / 1000 + 0.0001,\n    Math.round(b.lat * 1000) / 1000 - 0.0001,\n    Math.round(b.lng * 1000) / 1000 - 0.0001,\n  ].join(\",\");\n}\n\nexport class OverpassFetcher {\n  private hashMap = new Map<string, boolean>();\n  private downloadQueue = new DownloadQueue();\n  private layer: OverpassLayer;\n\n  constructor(readonly query: string, readonly delta) {}\n\n  // FIXME: It is not \"any\" array (create an type)\n  private getTiles(bounds: L.LatLngBounds): any[] {\n    const tn = Math.ceil((bounds.getNorth() + 90) / this.delta);\n    const ts = Math.floor((bounds.getSouth() + 90) / this.delta);\n    const te = Math.ceil((bounds.getEast() + 180) / this.delta);\n    const tw = Math.floor((bounds.getWest() + 180) / this.delta);\n    const retArr = [];\n    for (let i = ts; i < tn; i++) {\n      for (let j = tw; j < te; j++) {\n        retArr.push([i, j]);\n      }\n    }\n    return retArr;\n  }\n\n  private downloadTile(\n    x: number,\n    y: number,\n    callback: (data: object) => void\n  ): string {\n    const key = x + \":\" + y;\n    if (this.hashMap[key] === true) {\n      console.log(\"Already downloaded (\" + x + \":\" + y + \")\");\n      return;\n    }\n    // Check local storage\n    const currentDate = new Date();\n    const tileDate = localStorage.getItem(key + \"date\");\n    console.log(tileDate);\n    // FIXME: hardcoded cache time\n    const maxCacheTime = new Date();\n    maxCacheTime.setDate(currentDate.getDate() - 5);\n    // Use cache\n    if (\n      tileDate !== undefined &&\n      maxCacheTime.getTime() < new Date(tileDate).getTime()\n    ) {\n      const tileData = localStorage.getItem(key);\n      if (tileData !== undefined) {\n        console.log(\"Found in local storage (\" + x + \":\" + y + \")\");\n        this.hashMap[x + \":\" + y] = true;\n        console.log(tileData);\n        callback(JSON.parse(tileData));\n        return;\n      }\n    }\n\n    const bs = x * this.delta - 90;\n    const bw = y * this.delta - 180;\n    const bbox: L.LatLngBounds = new L.LatLngBounds(\n      [bs + this.delta, bw + this.delta],\n      [bs, bw]\n    );\n\n    const query =\n      \"[out:json][timeout:25];\" +\n      this.query\n        .replace(/%BBOX%/g, toOverpassString(bbox))\n        .replace(/(\\r\\n|\\n|\\r|\\\\n)/gm, \"\");\n\n    // Download\n    this.downloadQueue.enqueue({\n      input: \"http://overpass-api.de/api/interpreter?data=\",\n      init: {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n        body: `data=${encodeURIComponent(query)}`,\n      },\n      callback: (data) => {\n        console.log(\"Downloaded\");\n        // Save to local storage\n        localStorage.setItem(key, JSON.stringify(data));\n        localStorage.setItem(key + \"date\", new Date().toString());\n\n        callback(data);\n      },\n    });\n    this.hashMap[x + \":\" + y] = true;\n  }\n\n  // FIXME: interface or event instead\n  public setOverpassLayer(layer: OverpassLayer) {\n    this.layer = layer;\n  }\n\n  public onDownloaded(data: object) {\n    console.log(data);\n    if (this.layer !== undefined) {\n      this.layer.addData(data);\n    }\n  }\n\n  public fetchData(area: L.LatLngBounds) {\n    const tiles = this.getTiles(area);\n    tiles.forEach((element) => {\n      const [x, y] = element;\n      this.downloadTile(x, y, this.onDownloaded.bind(this));\n    });\n  }\n}\n","export type DownloadQueueRequest = {\n  input: RequestInfo | URL;\n  init?: RequestInit;\n  callback: (data: any) => void;\n};\n\nexport class DownloadQueue {\n  private queue: DownloadQueueRequest[];\n  private isDownloading: boolean;\n\n  constructor() {\n    this.queue = [];\n    this.isDownloading = false;\n  }\n\n  public enqueue(req: DownloadQueueRequest): void {\n    this.queue.push(req);\n    this.processQueue();\n  }\n\n  private processQueue(): void {\n    if (!this.isDownloading && this.queue.length > 0) {\n      const req = this.queue.shift();\n      if (req) {\n        this.downloadFile(req);\n      }\n    }\n  }\n\n  private downloadFile(req: DownloadQueueRequest): void {\n    this.isDownloading = true;\n\n    fetch(req.input, req.init)\n      .then((response) => response.json())\n      .then((json: JSON) => {\n        this.isDownloading = false;\n        req.callback(json);\n        this.processQueue();\n      })\n      .catch((error) => {\n        console.error(\"Error: \", req.input, error);\n        this.isDownloading = false;\n        this.processQueue();\n      });\n  }\n}\n"],"names":[],"version":3,"file":"index.js.map"}